# n 개의 물병을 가지고 있으며, 각 물병에는 무한대로 물을 부을 수 있다.
# 처음엔 모든 병에 물이 1리터씩 들어있고, 이 물병을 다른 장소로 옮기려도 한다.
# 한번에 k 개의 물병을 옮길 수 있다.
# 물 낭비를 하기 싫고, 이동을 한 번보다 많이 하기는 싫다
# 물병의 물을 적절하게 재분배해서, K개를 넘지 않는 비어있지 않은 물병을 만들려고 함
# 물을 재분배하는 방법: 같은 양의 물이 들어있는 물병 두개를 고르고, 그 다음에 한 개의 물병에 다른 한 쪽의 물을 모두 부음, 이 방법이 필요한 만큼 계속 수행
# 새로운 물병을 살 수 있다.
# 상점에서 사야하는 물병의 최솟값 -> 물병의 개수가 k 개가 되었을 때 까지 구매한 물병의 개수
# 정답이 없을 경우  -1 을 출력 -> 물병의 개수를 k 개 이하로 만들지 못하면 -1 을 출력

# 3 1
# 1 1 1 -> 2 1 -> (물병 구매) 2 1 1 -> 2 2 -> 4
# 4리터짜리 물병 1개로 만들어 장소를 옮길 수 있음

# 13 2
# 1 1 1 1 1 1 1 1 1 1 1 1 1 1
# 2 2 2 2 2 2 1
# 4 4 4 1
# 8 4 1
# 8 4 1 (1, 1, 1)
# 8 4 4
# 8 8
# 16

import sys


si = sys.stdin.readline

# n <= 10^7
# k <= 10^3
n, k = map(int, si().split())
answer = 0

while bin(n).count('1') > k:
    # 1이 오른쪽에서 몇 번째에 있는지 찾기
    # index('c') -> 가장 작은 인덱스의 c 의 위치를 찾아주는 함수(사야하는 물병의 최솟값을 구하기 위함)
    idx = bin(n)[::-1].index('1')
    # 2^idx 만큼 answer, n 갱신(비어있는 1 채우기)
    answer += 2 ** idx
    n += 2 ** idx

print(answer)
