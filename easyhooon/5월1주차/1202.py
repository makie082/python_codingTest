# 보석 도둑
# 정석적인 냅색? 근데 왜 골드 2지
# 아 이번엔 가방이 1개가 아니라 k 개이다...
# 가방에는 최대 '한개'의 보석만 넣을 수 있다.
# 훔칠 수 있는 보석 가격의 합의 최댓값
# dp 가 아니라고??
# 가장 가치가 큰 보석부터 넣을 수 있는 가방에 하나씩 넣어주기

# 2 1
# 5 10
# 100 100
# 11

# (5, 10) 한 개만 넣을 수 있어서 10

# 3 2
# 1 65
# 5 23
# 2 99
# 10
# 2

# (65 + 23 + 99) + (99)
# 가 아니라(보석을 다른 가방에 이미 넣었다면, 그 보석은 다른 가방에 넣을 수 없음)
# 65 + 95 = 164
# 동일한 상태를 정의하기 위한 요소
# i 번째 가방 까지 고려하였을 때, j번 보석을 넣었고, 가격의 합이 같은 경우
import sys
import heapq

si = sys.stdin.readline

# n 보석의 개수 <= 300,000
# k 가방의 개수 <= 300,000
n, k = map(int, si().split())

jews = []
bags = []

for _ in range(n):
    m, v = map(int, si().split())
    jews.append((m, v))

for _ in range(k):
    c = int(si())
    bags.append(c)

jews.sort()
bags.sort()

answer = 0
pq = []

# 문제: 무조건 가치가 큰걸 무게를 많이 담을 수 있는 가방에 넣는건 옳지 않다
# 괜히 가치가 큰걸 무게 많이 담을 수 있는 가방에 넣으면, 나머지 보석들을 못넣을 수 있다. 한 개씩 넣는거라 딱 맞는거에 넣는게 베스트일 수 도
# 2 2
# 5 100
# 50 10
# 50
# 20

# (5, 100)을 20에 넣고, (50, 10) 을 50에 넣으면 됨
# 가장 적절한 가방을 찾는 방법이 뭘까
# 가장 적게 담을 수 있는 가방 부터 보석을 넣어야 함
# 가장 적게 담을 수 있는 가방에 넣을 수 있는 보석중 가장 가치가 큰 보석을 넣는 행위를 반복!

for i in range(k):
    # 보석이 존재하고, 가방에 담을 수 있는 보석이 있을 때
    while jews and jews[0][0] <= bags[i]:
        # 해당 보석들의 가격을 최대 힙으로 저장
        heapq.heappush(pq, -jews[0][1])
        # 최대 힙에 넣은 보석 제거
        heapq.heappop(jews)

    if pq:
        # 가방에 담을 수 있는 보석 중 가장 가치가 큰 보석을 빼냄
        max_value_jew = -heapq.heappop(pq)
        # 정답을 갱신
        answer += max_value_jew

print(answer)
